/*
 * User Authentication API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package userapiserver

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"regexp"
	"strings"

	grpctoken "github.com/ZolaraProject/library/grpctoken"
	jwtToken "github.com/ZolaraProject/library/jwtToken"
	logger "github.com/ZolaraProject/library/logger"
	pkiVaultService "github.com/ZolaraProject/pki-vault-service/pkivaultrpc"
	"github.com/ZolaraProject/user-api/models"
	"golang.org/x/crypto/bcrypt"
	"google.golang.org/grpc"
)

func LogIn(w http.ResponseWriter, r *http.Request) {
	ctx, grpcToken := grpctoken.CreateContextFromHeader(r, JwtSecretKey)

	var user models.UserSignInRequest

	err := json.NewDecoder(r.Body).Decode(&user)
	if err != nil {
		logger.Err(grpcToken, "failed to decode request body: %s", err)

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("failed to decode request body: %s", err.Error()))
		return
	}

	if user.Username == "" {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		writeStandardResponse(r, w, grpcToken, "username is required")
		return
	}
	if user.Password == "" {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		writeStandardResponse(r, w, grpcToken, "password is required")
		return
	}

	// Create gRPC client
	conn, err := grpc.Dial(fmt.Sprintf("%v:%v", PkiVaultServiceHost, PkiVaultServicePort), grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		logger.Err(grpcToken, "LogIn could not establish gRPC connection: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("LogIn could not establish gRPC connection: %v", err))
		return
	}
	defer conn.Close()
	client := pkiVaultService.NewPkiVaultServiceClient(conn)

	res, err := client.GetUsers(ctx, &pkiVaultService.UserRequest{
		Username: user.Username,
	})
	if err != nil {
		logger.Err(grpcToken, "GetUsers gRPC Error: %s", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("GetUsers gRPC Error: %s", err.Error()))
		return
	}

	if len(res.GetUsers()) == 0 {
		logger.Err(grpcToken, "user %s not found", user.Username)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusNotFound)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("user %s not found", user.Username))
		return
	}

	if !checkPasswordHash(res.GetUsers()[0].GetPassword(), user.Password) {
		logger.Err(grpcToken, "wrong password")
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnauthorized)
		writeStandardResponse(r, w, grpcToken, "wrong password")
		return
	}

	jwttoken, err := jwtToken.CreateToken(res.GetUsers()[0].GetId(), strings.EqualFold(res.GetUsers()[0].GetRole(), "admin"), JwtSecretKey)
	if err != nil {
		logger.Err(grpcToken, "failed to create token: %s", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnauthorized)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("failed to create token: %s", err.Error()))
		return
	}

	response, _ := json.Marshal(&models.Response{
		Token:   jwttoken,
		Message: "logged in",
	})

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(response)
}

func LogOut(w http.ResponseWriter, r *http.Request) {
	// ctx, grpcToken := grpctoken.CreateContextFromHeader(r)

	// // Create gRPC client
	// conn, err := grpc.Dial(fmt.Sprintf("%v:%v", PkiVaultServiceHost, PkiVaultServicePort), grpc.WithInsecure(), grpc.WithBlock())
	// if err != nil {
	// 	w.WriteHeader(http.StatusInternalServerError)
	// 	writeStandardResponse(r, w, grpcToken, fmt.Sprintf("CreateAbstractClass could not establish gRPC connection: %v", err))
	// 	return
	// }
	// defer conn.Close()
	// client := pkiVaultService.NewPkiVaultServiceClient(conn)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func RegisterUser(w http.ResponseWriter, r *http.Request) {
	ctx, grpcToken := grpctoken.CreateContextFromHeader(r, "")

	var user models.UserRegisterRequest

	err := json.NewDecoder(r.Body).Decode(&user)
	if err != nil {
		logger.Err(grpcToken, "failed to decode request body: %s", err)
		w.WriteHeader(http.StatusBadRequest)
		writeStandardResponse(r, w, grpcToken, "failed to decode request body")
		return
	}

	if err := validatePassword(user.Password); err != nil {
		logger.Err(grpcToken, "password validation failed: %s", err)
		w.WriteHeader(http.StatusBadRequest)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("password validation failed: %s", err.Error()))
		return
	}

	hashedPassword, err := hashPassword(user.Password)
	if err != nil {
		logger.Err(grpcToken, "failed to hash password: %s", err)
		w.WriteHeader(http.StatusBadRequest)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("failed to hash password: %s", err.Error()))
		return
	}

	// Create gRPC client
	conn, err := grpc.Dial(fmt.Sprintf("%v:%v", PkiVaultServiceHost, PkiVaultServicePort), grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		logger.Err(grpcToken, "RegisterUser could not establish gRPC connection: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("RegisterUser could not establish gRPC connection: %v", err))
		return
	}
	defer conn.Close()
	client := pkiVaultService.NewPkiVaultServiceClient(conn)

	res, err := client.CreateUser(ctx, &pkiVaultService.UserCreateRequest{
		Username: user.Username,
		Email:    user.Email,
		Password: hashedPassword,
	})
	if err != nil {
		logger.Err(grpcToken, "CreateUser gRPC Error: %s", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("CreateUser gRPC Error: %s", err.Error()))
		return
	}

	response, err := json.Marshal(&models.UserCreatedResponse{
		Token:     grpcToken,
		CreatedId: res.GetCreatedId(),
		Message:   res.GetMessage(),
	})
	if err != nil {
		logger.Err(grpcToken, "failed to marshal response: %s", err)
		w.WriteHeader(http.StatusInternalServerError)
		writeStandardResponse(r, w, grpcToken, fmt.Sprintf("failed to marshal response: %s", err.Error()))
		return
	}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(response)
}

func validatePassword(password string) error {
	var passwordRegEx = regexp.MustCompile(`^.{7,35}$`)
	var digitCheck = regexp.MustCompile(`\d`)
	var lowerCheck = regexp.MustCompile(`[a-z]`)
	var upperCheck = regexp.MustCompile(`[A-Z]`)
	var specialCheck = regexp.MustCompile(`[!@#$%^&*()_+}{":;'?/>.<,]`)
	var spaceCheck = regexp.MustCompile(`\s`)

	if !passwordRegEx.MatchString(password) {
		log.Printf("Password %s is not between 7 and 35 characters", password)
		return fmt.Errorf("password %s is not between 7 and 35 characters", password)
	}
	if !digitCheck.MatchString(password) {
		log.Printf("Password %s does not contain a digit", password)
		return fmt.Errorf("password %s does not contain a digit", password)
	}
	if !lowerCheck.MatchString(password) {
		log.Printf("Password %s does not contain a lowercase letter", password)
		return fmt.Errorf("password %s does not contain a lowercase letter", password)
	}
	if !upperCheck.MatchString(password) {
		log.Printf("Password %s does not contain an uppercase letter", password)
		return fmt.Errorf("password %s does not contain an uppercase letter", password)
	}
	if !specialCheck.MatchString(password) {
		log.Printf("password %s does not contain a special character. Allowed special characters are: !@#$%%^&*()_+}{\":;'?/>.<,", password)
		return fmt.Errorf("password %s does not contain a special character. Allowed special characters are: !@#$%%^&*()_+}{\":;'?/>.<,", password)
	}
	if spaceCheck.MatchString(password) {
		log.Printf("Password %s contains a space", password)
		return fmt.Errorf("password %s contains a space", password)
	}

	return nil
}

func hashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(bytes), err
}

func checkPasswordHash(hashedPassword string, password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
	return err == nil
}
